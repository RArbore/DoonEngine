//INCLUDES "voxelShared.comp"
#version 430 core
#define INV_GAMMA 0.4545 //for gamma correction (1 / 2.2)

layout(local_size_x = 16, local_size_y = 16) in; //16x16 local group size
layout(rgba32f, binding = 0) uniform image2D colorOutput; //the color output texture
layout(rgba32f, binding = 1) uniform image2D depthOutput; //the depth output texture

uniform vec3 camPos;    //the camera's position
uniform vec3 camDir;    //the direction the camera is pointing
uniform vec3 camPlaneU; //the vector that points along the x-axis of the screen
uniform vec3 camPlaneV; //the vector that points along the y-axis of the screen

uniform uint viewMode;  //what is displayed, 0 = lighting, 1 = albedo, 2 = diffuse light, 3 - specular light, 4 = normals

uniform mat4 viewMat;		//the view matrix used to rasterize any objects, used to determine the depth
uniform mat4 projectionMat; //the projection matrix used to rasterize any objects, used to determine the depth
uniform mat4 modelMat;

//--------------------------------------------------------------------------------------------------------------------------------//

void main()
{
	Voxel finalVoxel;       //the final voxel that is hit
	Material finalMaterial; //the material of the final voxel hit
	vec3 finalColorAdd;     //added to the final color to account for transparency
	float finalColorMult;   //multiplied with the final color to account for transparency
	vec3 finalColor;        //the final color that gets written to the texture
	bool voxelHit;			//whether or not a voxel was hit

	//calculate ray position and direction:
	ivec2 coords = ivec2(gl_GlobalInvocationID.xy);
	vec2 screenPos = coords / vec2(imageSize(colorOutput)) * 2.0 - 1.0;

	mat4 invViewMat = inverse(viewMat);
	mat4 invProjectionMat = inverse(projectionMat);

	vec3 rayPos = (invViewMat * vec4(0.0, 0.0, 0.0, 1.0)).xyz;
	vec3 rayDir = camDir + screenPos.x * camPlaneU + screenPos.y * camPlaneV;
	vec3 invRayDir = 1.0 / rayDir;

	//check if ray hits the map at all:
	vec2 intersection = intersect_AABB(invRayDir, rayPos, vec3(0.0), mapSize);

	if(intersection.x > intersection.y || intersection.y < 0) //make sky color if no intersection at all
	{
		finalColor = sky_color(normalize(rayDir));
		voxelHit = false;
	}
	else //if the map is hit, step through it
	{
		if(intersection.x > 0) //only increment rayPos if outside the box
			rayPos += rayDir * (intersection.x + EPSILON);

		if(step_map(rayDir, invRayDir, rayPos, false, finalVoxel, finalColorAdd, finalColorMult))
		{
			voxelHit = true;

			finalMaterial = materials[finalVoxel.material];
			finalVoxel.specLight     *= finalMaterial.specular;
			finalVoxel.diffuseLight  *= 1.0 - finalMaterial.specular;

			switch(viewMode)
			{
			case 0: //total lighting
			{	
				vec3 solidColor;
				if(finalMaterial.emissive)
					solidColor = finalVoxel.albedo;
				else
					solidColor = ambientStrength * finalVoxel.albedo + finalVoxel.specLight + finalVoxel.diffuseLight;

				finalColor = pow(solidColor * finalColorMult + finalColorAdd, vec3(INV_GAMMA));
				break;
			}
			case 1: //albedo
			{
				finalColor = pow( finalVoxel.albedo, vec3(INV_GAMMA));
				break;
			}
			case 2: //diffuse light
			{
				finalColor = pow(finalMaterial.emissive ? finalVoxel.albedo : finalVoxel.diffuseLight / finalVoxel.albedo, vec3(INV_GAMMA));
				break;
			}
			case 3: //specular light
			{
				finalColor = pow(finalMaterial.emissive ? finalVoxel.albedo : finalVoxel.specLight, vec3(INV_GAMMA));
				break;
			}
			case 4: //normal
			{
				finalColor = vec3(abs(finalVoxel.normal));
				break;
			}
			}

			uvec3 mapPos = uvec3(floor(rayPos));
			uint index = mapPos.x + mapSize.x * (mapPos.y + mapSize.y * mapPos.z);

			if(map[index].visible == 0)
				map[index].visible = 1;
		}
		else
		{
			finalColor = sky_color(normalize(rayDir));
			voxelHit = false;

			if(viewMode == 0)
				finalColor = finalColor * finalColorMult + finalColorAdd;
		}
	}

	//transform point:
	vec4 transformedIntersectionPoint = projectionMat * viewMat * vec4(rayPos, 1.0);
	if(!voxelHit)
	{
		transformedIntersectionPoint.z = 0.99;
		transformedIntersectionPoint.w = 1.0;
	}

	//store final color to texture:
	imageStore(colorOutput, coords, vec4(finalColor, 1.0));
	imageStore(depthOutput, coords, transformedIntersectionPoint);
}
