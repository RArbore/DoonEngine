//----------------------------------------------------------BEGIN-SHARED----------------------------------------------------------//

#define CHUNK_SIZE ivec3(8, 8, 8) //size of each individual chunk
#define INV_CHUNK_SIZE vec3(0.125, 0.125, 0.125) //1 / CHUNK_SIZE, precomputed
#define HALF_INV_CHUNK_SIZE vec3(0.0625, 0.0625, 0.0625) //1 / 2 * CHUNK_SIZE, precomputed

#define EPSILON 0.0001 //to fix floating point error

uniform uvec3 mapSize;

//--------------------------------------------------------------------------------------------------------------------------------//

struct Voxel //a single voxel
{
	vec3 normal;       //the direction the voxel points (for lighting calculation)
	uint material;     //the index of this voxel's material

	vec3 directLight;  //the direct lighting from the sun, creates shadows
	vec3 specLight;    //the lighting caused by reflecting light rays off of the voxel
	vec3 diffuseLight; //the diffuse lighting of the voxel, caused by multiple light ray bounces
};

struct CompressedVoxel //a compressed voxel
{
	uint normal;       //layout: normal.x (8 bits)        | normal.y (8 bits)      | normal.z (8 bits)        | material index (8 bits)
	uint directLight;  //layout: directLight.x (8 bits)   | directLight.y (8 bits) | directLight.z (8 bits)   | specLight.x (8 bits)
	uint specLight;    //layout: specLight.y (8 bits)     | specLight.z (8 bits)   | diffuseLight.x (16 bits)
	uint diffuseLight; //layout: diffuseLight.y (16 bits)                          | diffuseLight.z (16 bits)
};

struct Chunk //a chunk of voxels
{
	ivec3 pos;				 //the chunk's position within the map
	uint numIndirectSamples; //the number of diffuse lighting samples this chunk has taken

	CompressedVoxel voxels[8][8][8]; //the grid of voxels
};

struct ChunkHandle //a handle to a Chunk
{
	uint flag;     //0 = does not exist, 1 = loaded on CPU but not GPU, 2 = loaded on CPU and GPU, 3 = loaded on CPU and requested on GPU
	uint visible;  //whether or not the chunk is visible to the camera
	uint lastUsed; //the time since the chunk was last used
	uint index;    //the index of the chunk in the chunk buffer
};

struct Material
{
	vec3 albedo;      //the "base color" of the material, the proportion of light reflected
	bool emissive;    //whether or not the voxel emits light
	float opacity;    //the opacity of the voxel
	float specular;   //what percentage of rays are specular, the other percent are diffuse
	uint reflectType; //only applies to specular voxels. whether or not they will reflect the sky color
	uint shininess;   //the greater the number, the closer the specular rays are to perfect reflection
};

//--------------------------------------------------------------------------------------------------------------------------------//

layout(std140, binding = 0) restrict buffer mapBuffer //the buffer that contains the chunk map
{
	ChunkHandle map[];
};

layout(std140, binding = 1) restrict buffer chunkBuffer //the buffer that contains all of the chunks
{
	Chunk chunks[];
};

layout(std140, binding = 2) restrict readonly buffer materialBuffer //the buffer that contains all of the materials
{
	Material materials[256];
};

uniform vec3 sunStrength;     //the amount of light the sun emits
uniform vec3 ambientStrength; //the minimum light that every voxel receives

//--------------------------------------------------------------------------------------------------------------------------------//

uvec4 decode_uint_RGBA(uint val) //decompresses a 4-byte value into 4 1-byte values
{
	uvec4 res;
	res.x = val >> 24;
	res.y = val >> 16;
	res.z = val >> 8;
	res.w = val;
	return res & 0xFF;
}

uint encode_uint_RGBA(uvec4 val) //compresses 4 1-byte values into a 4-byte value
{
	val = val & 0xFF;
	return val.x << 24 | val.y << 16 | val.z << 8 | val.w;
}

//--------------------------------------------------------------------------------------------------------------------------------//

bool in_map_bounds(ivec3 pos) //returns whether a position is in bounds in the map
{
	return pos.x < mapSize.x && pos.y < mapSize.y && pos.z < mapSize.z && pos.x >= 0 && pos.y >= 0 && pos.z >= 0;
}

bool in_chunk_bounds(ivec3 pos) //returns whether a position is in bounds in a chunk
{
	return pos.x < CHUNK_SIZE.x && pos.y < CHUNK_SIZE.y && pos.z < CHUNK_SIZE.z && pos.x >= 0 && pos.y >= 0 && pos.z >= 0;
}

ChunkHandle get_map_tile(ivec3 pos) //returns the value of the map at a position
{
	uint index = pos.x + mapSize.x * (pos.y + mapSize.y * pos.z);
	return map[index];
}

CompressedVoxel get_voxel(uint chunk, ivec3 pos) //returns the voxel of a chunk at a position
{
	return chunks[chunk].voxels[pos.x][pos.y][pos.z];
}

bool does_voxel_exist(uint chunk, ivec3 localPos) //returns true if the voxel at the position is solid (not empty)
{
	CompressedVoxel voxel = get_voxel(chunk, localPos);
	uint material = voxel.normal & 0xFF;
	return material < 255;
}

//--------------------------------------------------------------------------------------------------------------------------------//

Voxel decompress_voxel(CompressedVoxel compressed) //decompresses an entire voxel
{
	Voxel res;

	uvec4 normalRead 		= decode_uint_RGBA(compressed.normal);
	uvec4 directLightRead   = decode_uint_RGBA(compressed.directLight);
	uvec4 specLightRead 	= decode_uint_RGBA(compressed.specLight);
	uvec4 diffuseLightRead  = decode_uint_RGBA(compressed.diffuseLight);

	uvec3 diffuseUpper = uvec3(specLightRead.z, diffuseLightRead.x, diffuseLightRead.z) << 8;
	uvec3 diffuseLower = uvec3(specLightRead.w, diffuseLightRead.y, diffuseLightRead.w);
	vec3 diffuseLight  = vec3(diffuseUpper | diffuseLower);

	res.normal       = (vec3(normalRead.xyz) * 0.00392156862 - 0.5) * 2.0;
	res.material     = normalRead.w;
	res.diffuseLight = vec3(diffuseLight * 0.0000152590219);
	res.directLight  = vec3(directLightRead.xyz) * 0.00392156862;
	res.specLight    = vec3(directLightRead.w, specLightRead.xy) * 0.00392156862;

	return res;
}

//--------------------------------------------------------------------------------------------------------------------------------//

vec2 intersect_AABB(vec3 invRayDir, vec3 rayPos, vec3 boxMin, vec3 boxMax) //returns how far along a ray a box is intersected
{
    vec3 tMin = (boxMin - rayPos) * invRayDir;
    vec3 tMax = (boxMax - rayPos) * invRayDir;

    vec3 t1 = min(tMin, tMax);
    vec3 t2 = max(tMin, tMax);

    float tNear = max(max(t1.x, t1.y), t1.z);
    float tFar  = min(min(t2.x, t2.y), t2.z);

    return vec2(tNear, tFar);
}

//--------------------------------------------------------------------------------------------------------------------------------//

vec3 sky_color(vec3 rayDir)
{
	//return mix(vec3(0.99, 0.51, 0.0), vec3(0.66, 0.55, 0.78), rayDir.y * 0.5 + 1); //sunset
	//return mix(vec3(0.02, 0.05, 0.2), vec3(0.00, 0.04, 0.18), rayDir.y * 0.5 + 1); //night
	return mix(vec3(0.71, 0.85, 0.90), vec3(0.00, 0.45, 0.74), rayDir.y * 0.5 + 1); //day
}

//--------------------------------------------------------------------------------------------------------------------------------//

void iterate_DDA(vec3 deltaDist, ivec3 rayStep, inout vec3 sideDist, inout ivec3 mapPos) //steps through one tile with the DDA algorithm
{
	//https://www.youtube.com/watch?v=NbSee-XM7WA <- see this video for a good overview of the algorithm

	if (sideDist.x < sideDist.y) 
	{
		if (sideDist.x < sideDist.z) 
		{
			sideDist.x += deltaDist.x;
			mapPos.x += rayStep.x;
		}
		else 
		{
			sideDist.z += deltaDist.z;
			mapPos.z += rayStep.z;
		}
	}
	else
	{
		if (sideDist.y < sideDist.z) 
		{
			sideDist.y += deltaDist.y;
			mapPos.y += rayStep.y;
		}
		else 
		{
			sideDist.z += deltaDist.z;
			mapPos.z += rayStep.z;
		}
	}
}

//--------------------------------------------------------------------------------------------------------------------------------//

uint lastVox = 255; //used for transparent voxels

bool step_chunk(uint chunk, vec3 rayDir, vec3 invRayDir, vec3 rayPos, bool ignoreFirst, out Voxel voxel, out ivec3 chunkPos, inout vec3 colorAdd, inout float colorMult) //steps a ray through a chunk, returns true if something was hit
{
	ivec3 pos = ivec3(floor(rayPos));    //the position within the chunk
	vec3 deltaDist = abs(invRayDir);     //the distance the ray has to travel to move one unit in each direction
	ivec3 rayStep = ivec3(sign(rayDir)); //the direction the ray steps
	vec3 sideDist = (sign(rayDir) * (pos - rayPos) + (sign(rayDir) * 0.5) + 0.5) * deltaDist; //the total distance the ray has to travel to reach one additional unit in each direction (accounts for starting position as well)

	while(in_chunk_bounds(pos))
	{
		//check if a solid voxel has been hit:
		if (does_voxel_exist(chunk, pos) && !ignoreFirst)
		{
			//decompress the voxel and find its material:
			voxel = decompress_voxel(get_voxel(chunk, pos));
			Material material = materials[voxel.material];

			if(material.opacity < 1.0 && voxel.material < 255)
			{
				//if the voxel is transparent, add its transparency multiplier (only if it is a "new" voxel)
				if(lastVox != voxel.material)
				{
					colorAdd += colorMult * material.opacity * material.albedo * sunStrength; //TODO: REFRACTION AND BEER'S LAW
					colorMult *= 1.0 - material.opacity;
				}
			}
			else
			{
				//return the position
				chunkPos = pos;
				return true;
			}

			lastVox = voxel.material;
		}
		else
			lastVox = 255;

		//iterate the dda algorithm:
		iterate_DDA(deltaDist, rayStep, sideDist, pos);
		ignoreFirst = false;
	}

	return false;
}

bool step_map(vec3 rayDir, vec3 invRayDir, inout vec3 rayPos, bool ignoreFirst, out Voxel voxel, out vec3 colorAdd, out float colorMult) //steps a ray through the map (not individual chunks), returns true if something was hit
{
	colorAdd = vec3(0.0); //added to the final color to account for transparency
	colorMult = 1.0;      //multiplied with the final color to account for transparency

	ivec3 pos = ivec3(floor(rayPos));    //the position within the map
	vec3 deltaDist = abs(invRayDir);     //the distance the ray has to travel to move one unit in each direction
	ivec3 rayStep = ivec3(sign(rayDir)); //the direction the ray steps
	vec3 sideDist = (sign(rayDir) * (pos - rayPos) + (sign(rayDir) * 0.5) + 0.5) * deltaDist; //the total distance the ray has to travel to reach one additional unit in each direction (accounts for starting position as well)
	vec3 updatedRayDir = (abs(rayDir) + EPSILON) * sign(rayDir); //to reduce noise

	while(in_map_bounds(pos))
	{
		//check if a solid chunk has been hit:
		ChunkHandle mapTile = get_map_tile(pos);
		if (mapTile.flag == 2)
		{
			vec2 intersection = intersect_AABB(invRayDir, rayPos, pos, pos + 1.0); //find exactly where the ray intersects
			if(intersection.x > 0) //only increment rayPos if outside the box
				rayPos += updatedRayDir * (intersection.x - EPSILON); //add so that new pos is inside the chunk

			vec3 chunkRayPos = (rayPos - pos) * CHUNK_SIZE;
			chunkRayPos = clamp(chunkRayPos, vec3(EPSILON), CHUNK_SIZE - EPSILON); //try to reduce noise. TODO: remove noise entirely

			//step through the chunk:
			ivec3 chunkPos;
			if(step_chunk(mapTile.index, rayDir, invRayDir, chunkRayPos, ignoreFirst, voxel, chunkPos, colorAdd, colorMult))
			{
				vec3 voxelPos = pos + chunkPos * INV_CHUNK_SIZE;
				intersection = intersect_AABB(invRayDir, rayPos, voxelPos, voxelPos + INV_CHUNK_SIZE); //find exactly where the ray intersects
				rayPos += rayDir * (intersection.x + EPSILON); //add so that new pos is inside the voxel

				uint index = pos.x + mapSize.x * (pos.y + mapSize.y * pos.z);

				if(map[index].lastUsed > 0)
					map[index].lastUsed = 0;

				return true;
			}
		}
		else if(mapTile.flag == 1)
		{
			uint index = pos.x + mapSize.x * (pos.y + mapSize.y * pos.z);
			map[index].flag = 3;
			return false;
		}

		//iterate the dda algorithm:
		iterate_DDA(deltaDist, rayStep, sideDist, pos);
		ignoreFirst = false;
	}

	return false;
}

//-----------------------------------------------------------END-SHARED-----------------------------------------------------------//
