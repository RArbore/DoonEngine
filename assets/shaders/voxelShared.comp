//----------------------------------------------------------BEGIN-SHARED----------------------------------------------------------//

#define CHUNK_SIZE ivec3(8, 8, 8) //size of each individual chunk
#define INV_CHUNK_SIZE vec3(0.125, 0.125, 0.125) //1 / CHUNK_SIZE, precomputed
#define HALF_INV_CHUNK_SIZE vec3(0.0625, 0.0625, 0.0625) //1 / 2 * CHUNK_SIZE, precomputed

#define MAP_SIZE ivec3(3, 3, 3) //size of the map (number of chunks in each direction)

#define MAX_CHUNKS 11 //the maximum number of chunks that can be stored at once

#define EPSILON 0.00001 //to fix floating point error

//--------------------------------------------------------------------------------------------------------------------------------//

struct Voxel //a single voxel
{
	vec3 albedo;
	uint material;

	vec3 indirectLight;
	float indirectSamples;

	vec3 directLight;
};

struct CompressedVoxel //a compressed voxel
{
	uint albedo; //TODO: find something to do with the extra 2 floats of space thats lost to alignment
	uint directLight;
};

struct Chunk //a chunk of voxels
{
	CompressedVoxel voxels[CHUNK_SIZE.x][CHUNK_SIZE.y][CHUNK_SIZE.z];
	vec4 indirectLight[CHUNK_SIZE.x][CHUNK_SIZE.y][CHUNK_SIZE.z];
};

//--------------------------------------------------------------------------------------------------------------------------------//

layout(std140, binding = 0) restrict buffer mapBuffer //the buffer that contains the chunk map
{
	int map[MAP_SIZE.x][MAP_SIZE.y][MAP_SIZE.z];
};

layout(std140, binding = 1) restrict buffer chunkBuffer //the buffer that contains all of the chunks
{
	Chunk chunks[MAX_CHUNKS];
};

//--------------------------------------------------------------------------------------------------------------------------------//

uvec4 decode_uint_RGBA(uint val)
{
	uvec4 res;
	res.x = val >> 24;
	res.y = val >> 16;
	res.z = val >> 8;
	res.w = val;
	return res & 0xFF;
}

uint encode_uint_RGBA(uvec4 val)
{
	val = val & 0xFF;
	return val.x << 24 | val.y << 16 | val.z << 8 | val.w;
}

//--------------------------------------------------------------------------------------------------------------------------------//

bool in_map_bounds(ivec3 pos) //returns whether a position is in bounds in the map
{
	return pos.x < MAP_SIZE.x && pos.y < MAP_SIZE.y && pos.z < MAP_SIZE.z && pos.x >= 0 && pos.y >= 0 && pos.z >= 0;
}

bool in_chunk_bounds(ivec3 pos) //returns whether a position is in bounds in a chunk
{
	return pos.x < CHUNK_SIZE.x && pos.y < CHUNK_SIZE.y && pos.z < CHUNK_SIZE.z && pos.x >= 0 && pos.y >= 0 && pos.z >= 0;
}

int get_map_tile(ivec3 pos) //returns the value of the map at a position DOESNT DO ANY BOUNDS CHECKING
{
	return map[pos.x][pos.y][pos.z];
}

CompressedVoxel get_voxel(uint chunk, ivec3 pos) //returns the voxel of a chunk at a position DOESNT DO ANY BOUNDS CHECKING
{
	return chunks[chunk].voxels[pos.x][pos.y][pos.z];
}

vec4 get_indirect_light(uint chunk, ivec3 pos)
{
	return chunks[chunk].indirectLight[pos.x][pos.y][pos.z];
}

//--------------------------------------------------------------------------------------------------------------------------------//

Voxel decompress_voxel(CompressedVoxel compressed, vec4 indirectLight)
{
	uvec4 albedo 		= decode_uint_RGBA(compressed.albedo);
	uvec4 directLight   = decode_uint_RGBA(compressed.directLight);

	Voxel res;
	res.albedo = albedo.xyz * 0.00392156862;
	res.material = albedo.w;
	res.indirectLight = indirectLight.xyz;
	res.indirectSamples = indirectLight.w;
	res.directLight = directLight.xyz * 0.00392156862;

	return res;
}

//--------------------------------------------------------------------------------------------------------------------------------//

bool is_voxel_open(uint chunk, ivec3 localPos)
{
	CompressedVoxel voxel = get_voxel(chunk, localPos);
	uint material = voxel.albedo & 0xFF;
	return material < 255;
}

bool is_face_open(ivec3 chunkPos, ivec3 localPos, ivec3 face)
{
	uint chunkIndex = get_map_tile(chunkPos);
	if(in_chunk_bounds(localPos + face))
	{
		if(is_voxel_open(chunkIndex, localPos + face))
			return false;
	}
	else if(in_map_bounds(chunkPos + face))
	{
		int newIndex = get_map_tile(chunkPos + face);
		if(newIndex < 0)
			return true;

		ivec3 newPos = ivec3(mod(localPos + face + CHUNK_SIZE, CHUNK_SIZE));
		return !is_voxel_open(newIndex, newPos);
	}

	return true;
}

//--------------------------------------------------------------------------------------------------------------------------------//

vec2 intersect_AABB(vec3 invRayDir, vec3 rayPos, vec3 boxMin, vec3 boxMax) //returns how far along a ray a box is intersected
{
    vec3 tMin = (boxMin - rayPos) * invRayDir;
    vec3 tMax = (boxMax - rayPos) * invRayDir;

    vec3 t1 = min(tMin, tMax);
    vec3 t2 = max(tMin, tMax);

    float tNear = max(max(t1.x, t1.y), t1.z);
    float tFar  = min(min(t2.x, t2.y), t2.z);

    return vec2(tNear, tFar);
}

vec3 normal_AABB(vec3 intersectPos, vec3 boxMin, vec3 boxMax) //returns the normal of an AABB at a point
{
	vec3 c = (boxMin + boxMax) * 0.5;
	vec3 p = intersectPos - c;
	vec3 d = (boxMax - boxMin) * 0.5;
	const float bias = 1.0 + EPSILON;

	return normalize(trunc(p / d * bias));
}

//--------------------------------------------------------------------------------------------------------------------------------//

void iterate_DDA(vec3 deltaDist, ivec3 rayStep, inout vec3 sideDist, inout ivec3 mapPos, out ivec3 normal) //steps through one tile with the DDA algorithm
{
	//https://www.youtube.com/watch?v=NbSee-XM7WA <- see this video for a good overview of the algorithm

	if (sideDist.x < sideDist.y) 
	{
		if (sideDist.x < sideDist.z) 
		{
			sideDist.x += deltaDist.x;
			mapPos.x += rayStep.x;
			normal = ivec3(-rayStep.x, 0, 0);
		}
		else 
		{
			sideDist.z += deltaDist.z;
			mapPos.z += rayStep.z;
			normal = ivec3(0, 0, -rayStep.z);
		}
	}
	else
	{
		if (sideDist.y < sideDist.z) 
		{
			sideDist.y += deltaDist.y;
			mapPos.y += rayStep.y;
			normal = ivec3(0, -rayStep.y, 0);
		}
		else 
		{
			sideDist.z += deltaDist.z;
			mapPos.z += rayStep.z;
			normal = ivec3(0, 0, -rayStep.z);
		}
	}
}

//--------------------------------------------------------------------------------------------------------------------------------//

bool step_chunk(uint chunk, vec3 rayDir, vec3 invRayDir, vec3 rayPos, bool ignoreFirst, out Voxel voxel, inout ivec3 normal, out ivec3 chunkPos) //steps a ray through a chunk, returns true if something was hit
{
	ivec3 mapPos = ivec3(floor(rayPos)); //the position in the voxel map
	vec3 deltaDist = abs(invRayDir);   //the distance the ray has to travel to move one unit in each direction
	ivec3 rayStep = ivec3(sign(rayDir)); //the direction the ray steps
	vec3 sideDist = (sign(rayDir) * (mapPos - rayPos) + (sign(rayDir) * 0.5) + 0.5) * deltaDist; //the total distance the ray has to travel to reach one additional unit in each direction (accounts for starting position as well)

	while(in_chunk_bounds(mapPos))
	{
		//check if a solid voxel has been hit:
		if (is_voxel_open(chunk, mapPos) && !ignoreFirst)
		{
			voxel = decompress_voxel(get_voxel(chunk, mapPos), get_indirect_light(chunk, mapPos));
			chunkPos = mapPos;

			return true;
		}

		//iterate the dda algorithm:
		iterate_DDA(deltaDist, rayStep, sideDist, mapPos, normal);
		ignoreFirst = false;
	}

	return false;
}

bool step_map(vec3 rayDir, vec3 invRayDir, inout vec3 rayPos, bool ignoreFirst, out Voxel voxel, inout ivec3 normal) //steps a ray through the map (not individual chunks), returns true if something was hit
{
	ivec3 mapPos = ivec3(floor(rayPos)); //the position in the voxel map
	vec3 deltaDist = abs(invRayDir);   //the distance the ray has to travel to move one unit in each direction
	ivec3 rayStep = ivec3(sign(rayDir)); //the direction the ray steps
	vec3 sideDist = (sign(rayDir) * (mapPos - rayPos) + (sign(rayDir) * 0.5) + 0.5) * deltaDist; //the total distance the ray has to travel to reach one additional unit in each direction (accounts for starting position as well)

	if(!in_map_bounds(mapPos)) //iterate once if not in bounds to stop from exiting if the ray is *just* outside
		iterate_DDA(deltaDist, rayStep, sideDist, mapPos, normal);

	while(in_map_bounds(mapPos))
	{
		//check if a solid voxel has been hit:
		int res = get_map_tile(mapPos);
		if (res >= 0)
		{
			vec2 intersection = intersect_AABB(invRayDir, rayPos, mapPos, mapPos + 1.0); //find exactly where the ray intersects
			if(intersection.x > 0) //only increment rayPos if outside the box
				rayPos += rayDir * (intersection.x + EPSILON); //add so that new pos is inside the chunk

			ivec3 chunkPos;
			if(step_chunk(res, rayDir, invRayDir, (rayPos - mapPos) * CHUNK_SIZE, ignoreFirst, voxel, normal, chunkPos))
			{
				intersection = intersect_AABB(invRayDir, rayPos, mapPos + chunkPos * INV_CHUNK_SIZE, mapPos + chunkPos * INV_CHUNK_SIZE + INV_CHUNK_SIZE); //find exactly where the ray intersects
				rayPos += rayDir * (intersection.x - EPSILON); //subtract so that new pos is outside voxel

				return true;
			}
		}

		//iterate the dda algorithm:
		iterate_DDA(deltaDist, rayStep, sideDist, mapPos, normal);
		ignoreFirst = false;
	}

	return false;
}

//-----------------------------------------------------------END-SHARED-----------------------------------------------------------//
