//INCLUDES "voxelShared.comp"
#version 430 core
#define INV_GAMMA 0.4545 //for gamma correction (1 / 2.2)

uniform sampler2D blueNoise;

uniform vec3 camPos;    //the camera's position
uniform vec3 camDir;    //the direction the camera is pointing
uniform vec3 camPlaneU; //the vector that points along the x-axis of the screen
uniform vec3 camPlaneV; //the vector that points along the y-axis of the screen

uniform vec3 sunDir; 		   //the vector that points towards the sun
uniform uint viewMode;  	   //determines what gets written to the final texture. 0 = normal view, 1 = per-pixel view, 2 = albedo, 3 = normals
uniform float ambientStrength; //the minimum light that every voxel receives

//--------------------------------------------------------------------------------------------------------------------------------//

vec3 ray_BRDF(Voxel vox, int noiseOffset)
{
	//TODO: find a better way to sample the blue noise, maybe make a const array? also, pre-normalize the texture

	vec3 randUnitSphere = texelFetch(blueNoise, ivec2((gl_GlobalInvocationID + noiseOffset) % 64), 0).xyz * 2.0 - 1.0;
	return normalize(vox.normal + normalize(randUnitSphere));
}

vec3 shadow_ray(vec3 rayPos, int noiseOffset)
{
	//calculate jittered sun direction by adding random value:
	//---------------------------------
	vec3 shadowJitter = texelFetch(blueNoise, ivec2((gl_GlobalInvocationID + noiseOffset) % 64), 0).xyz * 2.0 - 1.0;
	vec3 jitteredSunDir = normalize(sunDir * 10 + shadowJitter);

	//declare variables needed to step through map:
	//---------------------------------
	Voxel vox;
	ivec3 voxelPos;
	vec3 colorAdd;
	float colorMult;

	//step through the map, return the sun's strength if nothing is hit
	//---------------------------------
	if(step_map(jitteredSunDir, 1 / jitteredSunDir, rayPos, true, vox, voxelPos, colorAdd, colorMult))
		return vec3(0.0);
	else
		return vec3(0.6);
}

vec3 get_lighting(Voxel voxel, ivec3 voxelPos)
{
	//declare variables:
	//---------------------------------
	vec3 tcol = vec3(0.0); //total lighting color, what is returned
	vec3 fcol = vec3(1.0); //the the color multiplied to everything, all of the albedos multiplied together

	vec3 colorAdd;   //for transparency
	float colorMult; //for transparency

	vec3 rayDir; //the direction the ray points
	vec3 rayPos; //the ray's origin position

	//cast rays, bounce multiple times:
	//---------------------------------
	for(int i = 0; i < 3; i++)
	{
		//if i = 0, the ray has already been cast by the calling function, so skip
		if(i != 0)
		{
			//if no voxel is hit, return a little bit of light to account for atmospheric scattering
			if(!step_map(rayDir, 1 / rayDir, rayPos, true, voxel, voxelPos, colorAdd, colorMult))
			{
				tcol += fcol * max(dot(rayDir, sunDir), 0.0) * 0.5;
				break;
			}
		}

		//calculate new ray position and direction:
		//---------------------------------
		rayPos = vec3(voxelPos) * INV_CHUNK_SIZE + HALF_INV_CHUNK_SIZE;
		rayPos += (HALF_INV_CHUNK_SIZE - vec3(EPSILON)) * voxel.normal;

		rayDir = ray_BRDF(voxel, (i + 1) * 10);

		//calculate direct lighting and add to total:
		//---------------------------------
		vec3 dcol = shadow_ray(rayPos, i);

		fcol *= voxel.albedo;
		tcol += fcol * dcol;
	}

	//return:
	//---------------------------------
	return tcol;
}

void sum_lighting(Voxel voxel, ivec3 voxelPos)
{
	//calculate the map and chunk positions:
	//---------------------------------
	ivec3 mapPos   = voxelPos / CHUNK_SIZE;
	ivec3 chunkPos = voxelPos % CHUNK_SIZE;

	//reset lighting if needed:
	//---------------------------------
	uint reset = atomicOr(chunks[get_map_tile(mapPos).index].voxels[chunkPos.x][chunkPos.y][chunkPos.z].normal, 0xFF);
	if((reset & 0xFF) == 0)
	{
		chunks[get_map_tile(mapPos).index].voxels[chunkPos.x][chunkPos.y][chunkPos.z].lightingUpper = 0;
		chunks[get_map_tile(mapPos).index].voxels[chunkPos.x][chunkPos.y][chunkPos.z].lightingLower = 0;
	}

	//calculate color:
	//---------------------------------
	vec3 color = pow(get_lighting(voxel, voxelPos), vec3(INV_GAMMA));

	//compress color down to 1 byte per component
	//---------------------------------
	ivec3 writeColor = ivec3(color * 255);
	writeColor &= 0xFF;

	//try to add to the sample count:
	//---------------------------------
	int num = atomicAdd(chunks[get_map_tile(mapPos).index].voxels[chunkPos.x][chunkPos.y][chunkPos.z].lightingUpper, (1 << 16)) / (1 << 16);
	if(num < 255) //if below max samples, add color to sum:
	{
		atomicAdd(chunks[get_map_tile(mapPos).index].voxels[chunkPos.x][chunkPos.y][chunkPos.z].lightingUpper, writeColor.x);
		atomicAdd(chunks[get_map_tile(mapPos).index].voxels[chunkPos.x][chunkPos.y][chunkPos.z].lightingLower, (writeColor.y << 16) + writeColor.z);
	}
	else //if ablove max samples, subtract to get back to max: 
		atomicAdd(chunks[get_map_tile(mapPos).index].voxels[chunkPos.x][chunkPos.y][chunkPos.z].lightingUpper, -(1 << 16));
}

void main()
{
	Voxel finalVoxel;       //the final voxel that is hit
	Material finalMaterial; //the material of the final voxel hit
	vec3 finalColorAdd;     //added to the final color to account for transparency
	float finalColorMult;   //multiplied with the final color to account for transparency
	vec3 finalColor;        //the final color that gets written to the texture
	ivec3 voxelPosition = ivec3(0xFFFFFFFF);
	ivec2 textureCoords = ivec2(gl_GlobalInvocationID.xy);

	//calculate ray position and direction:
	vec2 screenPos;
	screenPos.x = gl_GlobalInvocationID.x / (float(gl_NumWorkGroups.x) * 8.0) - 1.0; //(0,0) at the center of the screen
	screenPos.y = gl_GlobalInvocationID.y / (float(gl_NumWorkGroups.y) * 8.0) - 1.0;

	vec3 rayDir = camDir + screenPos.x * camPlaneU + screenPos.y * camPlaneV;
	vec3 invRayDir = 1.0 / rayDir;
	vec3 rayPos = camPos;

	//check if ray hits the map at all:
	vec2 intersection = intersect_AABB(invRayDir, rayPos, vec3(0.0), mapSize);

	if(intersection.x > intersection.y || intersection.y < 0) //make sky color if no intersection at all
	{
		finalColor = sky_color(normalize(rayDir));
		imageStore(colorOutput, textureCoords, vec4(finalColor, 1.0));
	}
	else //if the map is hit, step through it
	{
		if(intersection.x > 0) //only increment rayPos if outside the box
			rayPos += rayDir * (intersection.x + EPSILON);

		if(step_map(rayDir, invRayDir, rayPos, false, finalVoxel, voxelPosition, finalColorAdd, finalColorMult)) //if hit, calculate lighting
		{
			switch(viewMode)
			{
			case 0:
			{
				sum_lighting(finalVoxel, voxelPosition);
				break;
			}
			case 1:
			{
				vec3 color = pow(get_lighting(finalVoxel, voxelPosition), vec3(INV_GAMMA));
				imageStore(colorOutput, textureCoords, vec4(color, 1.0));
				break;
			}
			case 2:
			{
				vec3 color = pow(finalVoxel.albedo, vec3(INV_GAMMA));
				imageStore(colorOutput, textureCoords, vec4(color, 1.0));
				break;
			}
			case 3:
			{
				imageStore(colorOutput, textureCoords, vec4(abs(finalVoxel.normal), 1.0));
				break;
			}
			}
		}
		else
		{
			voxelPosition = ivec3(0xFFFFFFFF);
			finalColor = sky_color(normalize(rayDir));

			if(viewMode == 0)
				finalColor = finalColor * finalColorMult + finalColorAdd;

			imageStore(colorOutput, textureCoords, vec4(finalColor, 1.0));
		}
	}

	//store final color to texture:
	imageStore(positionOutput, textureCoords, ivec4(voxelPosition, 0));
}