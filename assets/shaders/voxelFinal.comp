//INCLUDES "voxelShared.comp"
#version 460
#define INV_GAMMA 0.4545 //for gamma correction (1 / 2.2)

layout(local_size_x = 16, local_size_y = 16) in; //16x16 local group size
layout(rgba32f, binding = 0) uniform image2D colorOutput; //the output texture

uniform vec3 camPos;    //the camera's position
uniform vec3 camDir;    //the direction the camera is pointing
uniform vec3 camPlaneU; //the vector that points along the x-axis of the screen
uniform vec3 camPlaneV; //the vector that points along the y-axis of the screen

uniform uint viewMode;  //what is displayed, 0 = lighting, 1 = depth, 2 = normals

//--------------------------------------------------------------------------------------------------------------------------------//

vec3 sky_color(vec3 rayDir)
{
	return mix(vec3(0.71, 0.85, 0.90), vec3(0.00, 0.45, 0.74), rayDir.y * 0.5 + 1);
}

//--------------------------------------------------------------------------------------------------------------------------------//

void main()
{
	Voxel finalVoxel; //the final voxel that is hit
	vec3 finalColor; //the final color that gets written to the texture
	ivec3 finalNormal; //the final normal that is hit

	//calculate ray position and direction:
	vec2 screenPos;
	screenPos.x = gl_GlobalInvocationID.x / (gl_NumWorkGroups.x * 8.0) - 1.0; //(0,0) at the center of the screen
	screenPos.y = gl_GlobalInvocationID.y / (gl_NumWorkGroups.y * 8.0) - 1.0;

	vec3 rayDir = normalize(camDir + screenPos.x * camPlaneU + screenPos.y * camPlaneV);
	vec3 invRayDir = 1.0 / rayDir;
	vec3 rayPos = camPos;

	//check if ray hits the map at all:
	vec2 intersection = intersect_AABB(invRayDir, rayPos, vec3(0.0), MAP_SIZE);

	if(intersection.x > intersection.y || intersection.y < 0) //make sky color if no intersection at all
	{
		finalColor = sky_color(rayDir);
	}
	else //if the map is hit, step through it
	{
		if(intersection.x > 0) //only increment rayPos if outside the box
			rayPos += rayDir * (intersection.x + EPSILON);

		finalNormal = ivec3(normal_AABB(rayPos, vec3(0.0), MAP_SIZE));

		if(step_map(rayDir, invRayDir, rayPos, false, finalVoxel, finalNormal))
		{
			switch(viewMode)
			{
			case 0: //total lighting
			{	
				if(finalVoxel.material == -1) //add reflections (for perfect reflectors only) //TODO: replace with check if voxel is a perfect mirror
				{
					vec3 specColor;
					vec3 newDir = normalize(reflect(rayDir, finalNormal));

					Voxel reflectedVoxel;
					ivec3 reflectedNormal;
					if(step_map(newDir, 1 / newDir, rayPos, true, reflectedVoxel, reflectedNormal))
						specColor = reflectedVoxel.color;
					else
						specColor = sky_color(newDir);

					finalColor = pow(finalVoxel.directLight + finalVoxel.indirectLight + 0.1 * specColor * (finalVoxel.directLight + finalVoxel.indirectLight), vec3(INV_GAMMA));
				}
				else
					finalColor = pow(finalVoxel.directLight + finalVoxel.indirectLight, vec3(INV_GAMMA));

				break;
			}
			case 1: //albedo
			{
				finalColor = pow(finalVoxel.color, vec3(INV_GAMMA));
				break;
			}
			case 2: //direct light
			{
				finalColor = pow(finalVoxel.directLight, vec3(INV_GAMMA));
				break;
			}
			case 3: //indirect light
			{
				finalColor = pow(finalVoxel.indirectLight, vec3(INV_GAMMA));
				break;
			}
			case 4: //depth
			{
				finalColor = vec3(length(camPos - rayPos) / 32.0);
				break;
			}
			case 5: //normal
			{
				finalColor = vec3(abs(finalNormal));
				break;
			}
			}
		}
		else
		{
			finalColor = sky_color(rayDir);
		}
	}

	//store final color to texture:
	ivec2 coords = ivec2(gl_GlobalInvocationID.xy);
	imageStore(colorOutput, coords, vec4(finalColor, 1.0));
}