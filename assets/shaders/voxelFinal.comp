//INCLUDES "voxelShared.comp"
#version 430 core
#define INV_GAMMA 0.4545 //for gamma correction (1 / 2.2)

layout(local_size_x = 16, local_size_y = 16) in; //16x16 local group size
layout(rgba32f, binding = 0) restrict writeonly uniform image2D colorOutput; //the output texture
layout(rgba32i, binding = 1) restrict writeonly uniform iimage2D positionOutput;
uniform sampler2D blueNoise;

uniform vec3 camPos;    //the camera's position
uniform vec3 camDir;    //the direction the camera is pointing
uniform vec3 camPlaneU; //the vector that points along the x-axis of the screen
uniform vec3 camPlaneV; //the vector that points along the y-axis of the screen

uniform vec3 sunDir;

uniform uint viewMode;  //what is displayed, 0 = lighting, 1 = depth, 2 = normals

uniform float ambientStrength; //the minimum light that every voxel receives

//--------------------------------------------------------------------------------------------------------------------------------//

float rand(float seed) //returns a random float between -1 and 1
{
    return fract(sin(seed) * 43758.5453) * 2.0 - 1.0;
}

vec2 rand2(float seed) //returns a vec2 of random floats between -1 and 1
{
	return vec2(rand(seed), rand(seed * 2.0));
}

vec3 rand3(float seed) //returns a vec3 of random floats between -1 and 1
{
	return vec3(rand(seed), rand(seed * 2.0), rand(seed * 3.0));
}

vec3 rand_unit_sphere(float seed) //returns a vec3 of random floats between -1 and 1 that is inside the unit sphere (mag < 1) 
{
	while(true)
	{
		vec3 point = rand3(seed++);
		if(dot(point, point) >= 1.0)
			continue;

		return point;
	}
}

void main()
{
	Voxel finalVoxel;       //the final voxel that is hit
	Material finalMaterial; //the material of the final voxel hit
	vec3 finalColorAdd;     //added to the final color to account for transparency
	float finalColorMult;   //multiplied with the final color to account for transparency
	vec3 finalColor;        //the final color that gets written to the texture
	ivec3 voxelPosition = ivec3(0xFFFFFFFF);
	ivec2 coords = ivec2(gl_GlobalInvocationID.xy);

	//calculate ray position and direction:
	vec2 screenPos;
	screenPos.x = gl_GlobalInvocationID.x / (float(gl_NumWorkGroups.x) * 8.0) - 1.0; //(0,0) at the center of the screen
	screenPos.y = gl_GlobalInvocationID.y / (float(gl_NumWorkGroups.y) * 8.0) - 1.0;

	vec3 rayDir = camDir + screenPos.x * camPlaneU + screenPos.y * camPlaneV;
	vec3 invRayDir = 1.0 / rayDir;
	vec3 rayPos = camPos;

	//check if ray hits the map at all:
	vec2 intersection = intersect_AABB(invRayDir, rayPos, vec3(0.0), mapSize);

	if(intersection.x > intersection.y || intersection.y < 0) //make sky color if no intersection at all
	{
		finalColor = sky_color(normalize(rayDir));
		imageStore(colorOutput, coords, vec4(finalColor, 1.0));
	}
	else //if the map is hit, step through it
	{
		if(intersection.x > 0) //only increment rayPos if outside the box
			rayPos += rayDir * (intersection.x + EPSILON);

		if(step_map(rayDir, invRayDir, rayPos, false, finalVoxel, voxelPosition, finalColorAdd, finalColorMult)) //if hit, calculate lighting
		{
			//get positions of hit voxel:
			ivec3 chunkPos = voxelPosition / ivec3(CHUNK_SIZE);
			ivec3 localPos = voxelPosition % ivec3(CHUNK_SIZE);

			//reset lighting if needed:
			uint prev = atomicOr(chunks[get_map_tile(chunkPos).index].voxels[localPos.x][localPos.y][localPos.z].normal, 0xFF);
			if((prev & 0xFF) == 0)
			{
				chunks[get_map_tile(chunkPos).index].voxels[localPos.x][localPos.y][localPos.z].directLight = 0;
				chunks[get_map_tile(chunkPos).index].voxels[localPos.x][localPos.y][localPos.z].specLight = 0;
			}

			//LIGHTING HERE:

			finalColor = finalVoxel.albedo;
			vec3 jitter = texelFetch(blueNoise, ivec2(gl_GlobalInvocationID % 64), 0).xyz * 2.0 - 1.0;
			vec3 newSunDir = normalize(sunDir * 3 + jitter);
			ivec3 tempPos;
			vec3 newPos = INV_CHUNK_SIZE * localPos + chunkPos + HALF_INV_CHUNK_SIZE;
			newPos += (HALF_INV_CHUNK_SIZE - vec3(EPSILON)) * finalVoxel.normal;
			if(step_map(newSunDir, 1 / newSunDir, newPos, true, finalVoxel, tempPos, finalColorAdd, finalColorMult))
				finalColor *= 0.5;

			finalColor = pow(finalColor, vec3(INV_GAMMA));

			if(viewMode == 1)
				imageStore(colorOutput, coords, vec4(finalColor, 1.0));

			//END LIGHTING

			//compress color down to 1 byte per component
			ivec3 writeColor = ivec3(finalColor * 255);
			writeColor &= 0xFF;

			//try to add to the sample count:
			int num = atomicAdd(chunks[get_map_tile(chunkPos).index].voxels[localPos.x][localPos.y][localPos.z].directLight, (1 << 16)) / (1 << 16);
			if(num < 255) //if below max samples, add color to sum:
			{
				atomicAdd(chunks[get_map_tile(chunkPos).index].voxels[localPos.x][localPos.y][localPos.z].directLight, writeColor.x);
				atomicAdd(chunks[get_map_tile(chunkPos).index].voxels[localPos.x][localPos.y][localPos.z].specLight, (writeColor.y << 16) + writeColor.z);
			}
			else //if ablove max samples, subtract to get back to max: 
				atomicAdd(chunks[get_map_tile(chunkPos).index].voxels[localPos.x][localPos.y][localPos.z].directLight, -(1 << 16));

			imageStore(colorOutput, coords, vec4(finalColor, 1.0));

			/*switch(viewMode)
			{
			case 0: //total lighting
			{	
				vec3 solidColor;
				if(finalMaterial.emissive == 1)
					solidColor = finalVoxel.albedo;
				else
					solidColor = (finalVoxel.directLight + finalVoxel.indirectLight + ambientStrength) * finalVoxel.albedo + finalVoxel.specLight;

				finalColor = pow(solidColor * finalColorMult + finalColorAdd, vec3(INV_GAMMA));
				break;
			}
			case 1: //albedo
			{
				finalColor = pow(finalVoxel.albedo, vec3(INV_GAMMA));
				break;
			}
			case 2: //direct light
			{
				finalColor = pow(finalMaterial.emissive == 1 ? finalVoxel.albedo : finalVoxel.directLight, vec3(INV_GAMMA));
				break;
			}
			case 3: //indirect light
			{
				finalColor = pow(finalMaterial.emissive == 1 ? finalVoxel.albedo : finalVoxel.indirectLight, vec3(INV_GAMMA));
				break;
			}
			case 4: //specular light
			{
				finalColor = pow(finalMaterial.emissive == 1 ? finalVoxel.albedo : finalVoxel.specLight, vec3(INV_GAMMA));
				break;
			}
			case 5: //normal
			{
				finalColor = vec3(abs(finalVoxel.normal));
				break;
			}
			}*/
		}
		else
		{
			voxelPosition = ivec3(0xFFFFFFFF);
			finalColor = sky_color(normalize(rayDir));

			if(viewMode == 0)
				finalColor = finalColor * finalColorMult + finalColorAdd;

			imageStore(colorOutput, coords, vec4(finalColor, 1.0));
		}
	}

	//store final color to texture:
	//imageStore(colorOutput, coords, vec4(finalColor, 1.0));
	imageStore(positionOutput, coords, ivec4(voxelPosition, 0));
}