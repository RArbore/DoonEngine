//INCLUDES "voxelShared.comp"
#version 460

layout(local_size_x = CHUNK_SIZE.x, local_size_y = CHUNK_SIZE.y, local_size_z = CHUNK_SIZE.z) in; //local group size of chunk

layout(std140, binding = 2) restrict readonly buffer lightingRequestBuffer
{
	vec3 chunkPositions[];
};

//--------------------------------------------------------------------------------------------------------------------------------//

uniform float time;

float rand(vec2 seed) //returns a random float between -1 and 1
{
    return fract(sin(dot(seed, vec2(12.9898, 78.233))) * 43758.5453) * 2 - 1;
}

vec2 rand2(vec2 seed) //returns a vec2 of random floats between -1 and 1
{
	return vec2(rand(seed), rand(seed * 2));
}

vec3 rand3(vec2 seed) //returns a vec3 of random floats between -1 and 1
{
	return vec3(rand(seed), rand(seed * 2), rand(seed * 3));
}

vec3 rand_unit_sphere(vec2 seed) //returns a vec3 of random floats between -1 and 1 that is inside the unit sphere (mag < 1) 
{
	while(true)
	{
		vec3 point = rand3(seed);
		if(dot(point, point) >= 1)
			continue;

		return point;
	}
}

//--------------------------------------------------------------------------------------------------------------------------------//

bool shadow_ray(uint chunkIndex, vec3 face, vec3 rayPos, vec3 sunDir) //returns true if the shadow ray hit the map
{
	uvec3 localPos = gl_LocalInvocationID;

	if(!in_chunk_bounds(localPos + face) || get_voxel(chunkIndex, localPos + face).material < 0) //only send ray if the face is open
	{
		vec3 updatedRayPos = rayPos + (HALF_INV_CHUNK_SIZE - vec3(0.000001)) * face;

		Voxel temp; //stores the voxel that the shadow ray hits, not used currently
		vec3 temp2; //stores the normal of the shadow ray, not used currently
		
		return step_map(sunDir, 1 / sunDir, updatedRayPos, localPos, temp, temp2);
	}
	else
		return true;
}

//--------------------------------------------------------------------------------------------------------------------------------//

void main()
{
	uvec3 localPos = gl_LocalInvocationID;
	vec3 chunkPos = chunkPositions[gl_WorkGroupID.x].xyz;
	int chunkIndex = get_map_tile(chunkPos);
	if(get_voxel(chunkIndex, localPos).material < 0)
		return;
	
	vec3 rayPos = INV_CHUNK_SIZE * localPos + chunkPos + HALF_INV_CHUNK_SIZE;
	vec2 seed = vec2(chunkIndex, localPos.x + localPos.y * CHUNK_SIZE.x + localPos.z * CHUNK_SIZE.x * CHUNK_SIZE.y) + time;
	vec3 offset = rand3(seed) / 5;
	vec3 sunDir = normalize(vec3(1.0, 1.0, 1.0) + offset);

	bool hit = true;
	hit = shadow_ray(chunkIndex, vec3( 1,  0,  0), rayPos, sunDir) && hit;
	hit = shadow_ray(chunkIndex, vec3(-1,  0,  0), rayPos, sunDir) && hit;
	hit = shadow_ray(chunkIndex, vec3( 0,  1,  0), rayPos, sunDir) && hit;
	hit = shadow_ray(chunkIndex, vec3( 0, -1,  0), rayPos, sunDir) && hit;
	hit = shadow_ray(chunkIndex, vec3( 0,  0,  1), rayPos, sunDir) && hit;
	hit = shadow_ray(chunkIndex, vec3( 0,  0, -1), rayPos, sunDir) && hit;

	vec3 color;
	if(hit)
	{
		color = get_voxel(chunkIndex, localPos).color * 0.5;
	}
	else
	{
		color = get_voxel(chunkIndex, localPos).color;
	}

	chunks[chunkIndex].voxels[localPos.x][localPos.y][localPos.z].accumColor += color;
	chunks[chunkIndex].voxels[localPos.x][localPos.y][localPos.z].numSamples += 1;

	return;
}