//INCLUDES "voxelShared.comp"
#version 430 core

layout(local_size_x = CHUNK_SIZE.x, local_size_y = CHUNK_SIZE.y, local_size_z = CHUNK_SIZE.z) in; //local group size of chunk

layout(std140, binding = 3) restrict readonly buffer lightingRequestBuffer //a buffer that holds all of the chunks that are set to have their lighting updated
{
	ivec3 chunkPositions[];
};

uniform vec3 sunDir;           //the vector pointing towards the sun, must be normalized
uniform float shadowSoftness;  //how soft the shadows appear
uniform float ambientStrength; //essentially the minimum brightness of every voxel

uniform vec3 camPos; //the position of the camera

const vec3 spherePoints[15] = { vec3(0.000000, 1.000000, 0.000000), vec3(-0.379803, 0.857143, 0.347931), vec3(0.061185, 0.714286, -0.697174), vec3(0.499316, 0.571429, 0.651270), vec3(-0.889696, 0.428571, -0.157375), vec3(0.808584, 0.285714, -0.514354), vec3(-0.256942, 0.142857, 0.955810), vec3(-0.460906, 0.000000, -0.887449), vec3(0.929687, -0.142857, 0.339521), vec3(-0.885815, -0.285714, 0.365650), vec3(0.382949, -0.428571, -0.818338), vec3(0.245607, -0.571429, 0.783037), vec3(-0.605521, -0.714286, -0.350913), vec3(0.503065, -0.857143, -0.110596), vec3(-0.000000, -1.000000, 0.000000) };
//TODO: ALLOW MULTIPLE QUALITY OPTIONS FOR THE SPHERE POINTS

//--------------------------------------------------------------------------------------------------------------------------------//

bool shadow_ray(ivec3 chunkPos, ivec3 localPos, vec3 normal, vec3 rayPos, vec3 sunDir, out vec3 colorAdd, out float colorMult) //returns true if the shadow ray hit the map
{
	Voxel hitVoxel;

	return step_map(sunDir, 1 / sunDir, rayPos, true, false, hitVoxel, colorAdd, colorMult); //return whether or not the map was hit
}

void specular_ray(ivec3 chunkPos, ivec3 localPos, vec3 normal, vec3 rayPos, vec3 rayDir, vec3 albedo, uint reflectSky, inout vec3 color) //casts out a specular ray and adds the appropriate color to color
{
	Voxel hitVoxel;
	Material hitMaterial;

	vec3 lastPos = rayPos;    //the previous ray position
	vec3 multiplier = albedo; //all of the hit albedos multiplied together

	for(int i = 0; i < 2; i++)
	{
		vec3 colorAdd;
		float colorMult;

		//check if a voxel was hit:
		if(step_map(rayDir, 1 / rayDir, rayPos, true, false, hitVoxel, colorAdd, colorMult))
		{
			//check if hit voxel is adjacent (meant that this voxel is occluded):
			vec3 dist = abs(floor(rayPos * CHUNK_SIZE) - floor(lastPos * CHUNK_SIZE));
			if(dot(dist, dist) > 1)
			{
				hitMaterial = materials[hitVoxel.material];
				hitVoxel.indirectLight *= 1.0 - hitMaterial.specular;
				hitVoxel.directLight   *= 1.0 - hitMaterial.specular;	

				if(hitMaterial.emissive)
				{
					color += (hitVoxel.albedo * colorMult + colorAdd) * multiplier * albedo;
					break;
				}
				else
				{
					vec3 hitColor = (hitVoxel.directLight + hitVoxel.indirectLight + ambientStrength) * hitVoxel.albedo;	
					color += (hitColor * colorMult + colorAdd) * multiplier;

					//reflect ray again if the hit voxel is specular:
					if(hitMaterial.specular > 0.0)
					{
						multiplier *= hitVoxel.albedo * colorMult * hitMaterial.specular;
						reflectSky = hitMaterial.reflectSky;
						lastPos = rayPos;
						rayDir = reflect(rayDir, hitVoxel.normal);
					}
					else
						break;
				}
			}
			else
				break;
		}
		else if(dot(rayDir, sunDir) > 0.99) //add specular highlight
		{
			color += (sunStrength * colorMult + colorAdd);
			break;
		}
		else if(reflectSky == 1) //reflect the sky color
		{
			color += (sky_color(rayDir) * colorMult + colorAdd) * multiplier;
			break;
		}
		else //add some "ambient" specular light, probably not physically accurate but it looks good
		{
			color += (sunStrength * colorMult + colorAdd) * max(dot(rayDir, sunDir), 0.1) * multiplier;	
			break;
		}
	}
}

//--------------------------------------------------------------------------------------------------------------------------------//

void main()
{
	//TODO: COMBINE SPEC AND SHADOW RAYS, COMBINE DIRECT AND GLOBAL LIGHT SHADERS

	//find positions:
	ivec3 chunkPos = chunkPositions[gl_WorkGroupID.x].xyz;
	ivec3 localPos = ivec3(gl_LocalInvocationID);
	uint chunkIndex = get_map_tile(chunkPos).index;
	Voxel thisVoxel = decompress_voxel(get_voxel(chunkIndex, localPos), get_indirect_light(chunkIndex, localPos));
	Material thisMaterial = materials[thisVoxel.material];

	//return if voxel does not exist lol:
	if(thisVoxel.material == 255)
		return;
	
	//find position of ray (center of the voxel):
	vec3 rayPos = INV_CHUNK_SIZE * localPos + chunkPos + HALF_INV_CHUNK_SIZE;
	rayPos = rayPos + (HALF_INV_CHUNK_SIZE - vec3(EPSILON)) * thisVoxel.normal;

	//shadow rays:
	vec3 directLight = vec3(0.0);
	for(int i = 0; i < 15; i++)
	{
		vec3 updatedSunDir = sunDir * shadowSoftness + spherePoints[i];

		vec3 colorAdd;
		float colorMult;
		if(!shadow_ray(chunkPos, localPos, thisVoxel.normal, rayPos, updatedSunDir, colorAdd, colorMult))
			directLight += (sunStrength * colorMult + colorAdd) * colorMult; //not sure why I multiply by colorMult twice but it looks good
	}

	directLight /= 15.0;

	//specular rays:
	vec3 specLight = vec3(0.0);
	vec3 viewDir = rayPos - camPos; //the vector from the ray position to the camera
	if(thisMaterial.specular > 0.0 && dot(viewDir, thisVoxel.normal) < 0.0)
	{
		vec3 reflected = reflect(normalize(viewDir), thisVoxel.normal); //TODO: FRESNEL EFFECT

		for(int i = 0; i < 15; i++)
		{
			vec3 specDir = normalize(reflected * thisMaterial.shininess + spherePoints[i]);
			specular_ray(chunkPos, localPos, thisVoxel.normal, rayPos, specDir, thisVoxel.albedo, thisMaterial.reflectSky, specLight);
		}

		specLight /= 15.0;
	}

	//update the final color:
	directLight = clamp(directLight, vec3(0.0), vec3(1.0));
	specLight = clamp(specLight, vec3(0.0), vec3(1.0));

	atomicExchange(chunks[chunkIndex].voxels[localPos.x][localPos.y][localPos.z].directLight, encode_uint_RGBA(uvec4(round(directLight * 255), 0)));
	chunks[chunkIndex].voxels[localPos.x][localPos.y][localPos.z].specLight = encode_uint_RGBA(uvec4(round(specLight * 255), 0));

	return;
}