//INCLUDES "voxelShared.comp"
#version 460

layout(local_size_x = CHUNK_SIZE.x, local_size_y = CHUNK_SIZE.y, local_size_z = CHUNK_SIZE.z) in; //local group size of chunk

layout(std140, binding = 3) restrict readonly buffer lightingRequestBuffer
{
	ivec3 chunkPositions[];
};

//for seeding:
uniform float time;

//diffuse (indirect) params:
uniform int bounceLimit;
uniform float bounceStrength;

//global sun params:
uniform vec3 sunDir; //must be normalized

//--------------------------------------------------------------------------------------------------------------------------------//

float rand(float seed) //returns a random float between -1 and 1
{
    return fract(sin(seed) * 43758.5453) * 2 - 1;
}

vec2 rand2(float seed) //returns a vec2 of random floats between -1 and 1
{
	return vec2(rand(seed), rand(seed * 2));
}

vec3 rand3(float seed) //returns a vec3 of random floats between -1 and 1
{
	return vec3(rand(seed), rand(seed * 2), rand(seed * 3));
}

vec3 rand_unit_sphere(float seed) //returns a vec3 of random floats between -1 and 1 that is inside the unit sphere (mag < 1) 
{
	while(true)
	{
		vec3 point = rand3(seed++);
		if(dot(point, point) >= 1.0)
			continue;

		return point;
	}
}

//--------------------------------------------------------------------------------------------------------------------------------//

void diffuse_ray(ivec3 chunkPos, ivec3 localPos, vec3 normal, vec3 rayPos, Voxel initialVoxel, inout vec3 color) //increments color and numSamples depending on the voxel hit
{
	Voxel hitVoxel = initialVoxel; //stores the voxel that the ray hits
	vec3 hitNormal = normal; //stores the normal of the hit voxel

	vec3 newColor = vec3(1.0);

	vec3 lastPos = rayPos;
	vec3 lastDir;
	for(int i = 0; i < bounceLimit; i++)
	{
		vec3 dir;
		if(i > 0 && (rand(time + bounceLimit + i) + 1) * 0.5 < materials[hitVoxel.material].specular)
			dir = normalize(reflect(lastDir, hitNormal) * 10 + rand_unit_sphere(time + i)); //TODO: check if this actually works i cant tell with my current example scene
		else
			dir = normalize(hitNormal + rand_unit_sphere(time + i)); //randomize the direction, spherical sampling
		
		vec3 colorAdd;
		float colorMult;
		bool hit = step_map(dir, 1 / dir, rayPos, (i == 0), false, hitVoxel, colorAdd, colorMult);  //step through map
		hitNormal = hitVoxel.normal;

		if(hit)
		{
			vec3 dist = abs(floor(lastPos * CHUNK_SIZE) - floor(rayPos * CHUNK_SIZE)); //return if you hit an adjacent voxel (occluded)
			if(dot(dist, dist) < 1)
				return;

			if(materials[hitVoxel.material].emissive)
			{
				color += newColor * hitVoxel.albedo;
				return;
			}
			else
				newColor *= hitVoxel.albedo * bounceStrength;
		}
		else
		{
			color += (newColor * max(dot(dir, sunDir), 0.0) * sunStrength * colorMult + colorAdd) * colorMult;
			return;
		}

		lastDir = dir;
	}
}

//--------------------------------------------------------------------------------------------------------------------------------//

void main()
{
	//find positions:
	ivec3 chunkPos = chunkPositions[gl_WorkGroupID.x].xyz;
	ivec3 localPos = ivec3(gl_LocalInvocationID);
	int chunkIndex = get_map_tile(chunkPos);
	Voxel thisVoxel = decompress_voxel(get_voxel(chunkIndex, localPos), get_indirect_light(chunkIndex, localPos));

	//return if voxel does not exist lol:
	if(thisVoxel.material == 255)
		return;
	
	//find position of ray (center of the voxel):
	vec3 rayPos = INV_CHUNK_SIZE * localPos + chunkPos + HALF_INV_CHUNK_SIZE;
	rayPos = rayPos + (HALF_INV_CHUNK_SIZE - vec3(EPSILON)) * thisVoxel.normal;

	//send diffuse rays:
	//---------------------------------
	vec3 indirectLight = vec3(0.0);
	diffuse_ray(chunkPos, localPos, thisVoxel.normal, rayPos, thisVoxel, indirectLight);

	//update final lighting and increase number of samples
	//---------------------------------
	vec3 finalColor = (thisVoxel.indirectLight * thisVoxel.indirectSamples + indirectLight) / (thisVoxel.indirectSamples + 1.0);
	finalColor = clamp(finalColor, vec3(0.0), vec3(1.0));

	chunks[chunkIndex].indirectLight[localPos.x][localPos.y][localPos.z].xyz = finalColor;
	chunks[chunkIndex].indirectLight[localPos.x][localPos.y][localPos.z].w += 1.0;

	return;
}