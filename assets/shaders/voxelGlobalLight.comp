//INCLUDES "voxelShared.comp"
#version 460

layout(local_size_x = CHUNK_SIZE.x, local_size_y = CHUNK_SIZE.y, local_size_z = CHUNK_SIZE.z) in; //local group size of chunk

layout(std140, binding = 2) restrict readonly buffer lightingRequestBuffer
{
	ivec3 chunkPositions[];
};

//for seeding:
uniform float time;

//diffuse (indirect) params:
uniform int bounceLimit;
uniform float bounceStrength;

//global sun params:
uniform vec3 sunDir; //must be normalized
uniform float sunStrength;
uniform float ambientStrength;

//--------------------------------------------------------------------------------------------------------------------------------//

float rand(float seed) //returns a random float between -1 and 1
{
    return fract(sin(seed) * 43758.5453) * 2 - 1;
}

vec2 rand2(float seed) //returns a vec2 of random floats between -1 and 1
{
	return vec2(rand(seed), rand(seed * 2));
}

vec3 rand3(float seed) //returns a vec3 of random floats between -1 and 1
{
	return vec3(rand(seed), rand(seed * 2), rand(seed * 3));
}

vec3 rand_unit_sphere(float seed) //returns a vec3 of random floats between -1 and 1 that is inside the unit sphere (mag < 1) 
{
	while(true)
	{
		vec3 point = rand3(seed++);
		if(dot(point, point) >= 1.0)
			continue;

		return point;
	}
}

//--------------------------------------------------------------------------------------------------------------------------------//

void diffuse_ray(ivec3 chunkPos, ivec3 localPos, ivec3 face, vec3 rayPos, inout vec3 color, inout float numSamples) //increments color and numSamples depending on the voxel hit
{
	if(!is_open(chunkPos, localPos, face)) //return if the face isnt open
		return;

	numSamples++;

	Voxel hitVoxel; //stores the voxel that the ray hits
	ivec3 hitNormal = face; //stores the normal of the hit voxel
	vec3 updatedRayPos = rayPos + (HALF_INV_CHUNK_SIZE - vec3(EPSILON)) * hitNormal; //move ray position to the edge of the face

	vec3 newColor = vec3(1.0);
	for(int i = 0; i < bounceLimit; i++)
	{
		vec3 dir = normalize(hitNormal + rand_unit_sphere(time + i)); //randomize the direction, spherical sampling
		bool hit = step_map(dir, 1 / dir, updatedRayPos, (i == 0), hitVoxel, hitNormal);  //step through map

		if(hit)
			newColor *= hitVoxel.color * bounceStrength;
		else
		{
			color += newColor * max(dot(dir, sunDir), ambientStrength) * sunStrength;
			return;
		}
	}
}

//--------------------------------------------------------------------------------------------------------------------------------//

const ivec3 cubeFaces[6] = {ivec3(1, 0, 0), ivec3(-1, 0, 0), ivec3(0, 1, 0), ivec3(0, -1, 0), ivec3(0, 0, 1), ivec3(0, 0, -1)};

void main()
{
	//find positions:
	ivec3 chunkPos = chunkPositions[gl_WorkGroupID.x].xyz;
	ivec3 localPos = ivec3(gl_LocalInvocationID);
	int chunkIndex = get_map_tile(chunkPos);
	Voxel thisVoxel = get_voxel(chunkIndex, localPos);

	//return if voxel does not exist lol:
	if(thisVoxel.material < 0)
		return;
	
	//find position of ray (center of the voxel):
	vec3 rayPos = INV_CHUNK_SIZE * localPos + chunkPos + HALF_INV_CHUNK_SIZE;

	//send diffuse rays:
	//---------------------------------
	vec3 indirectLight = vec3(0.0);
	float indirectSamples = 0.0;

	for(int i = 0; i < 6; i++)
		diffuse_ray(chunkPos, localPos, cubeFaces[i], rayPos, indirectLight, indirectSamples);

	indirectLight /= indirectSamples;

	//update final lighting and increase number of samples 
	//---------------------------------
	chunks[chunkIndex].voxels[localPos.x][localPos.y][localPos.z].indirectLight   += (indirectLight * thisVoxel.color - thisVoxel.indirectLight) / (thisVoxel.indirectSamples + 1.0); 
	chunks[chunkIndex].voxels[localPos.x][localPos.y][localPos.z].indirectSamples += 1.0;

	return;
}