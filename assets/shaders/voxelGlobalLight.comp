//INCLUDES "voxelShared.comp"
#version 430 core

layout(local_size_x = CHUNK_SIZE.x, local_size_y = CHUNK_SIZE.y, local_size_z = CHUNK_SIZE.z) in; //local group size of chunk

layout(std140, binding = 3) restrict readonly buffer lightingRequestBuffer //a buffer that holds all of the chunks that are set to have their lighting updated
{
	ivec3 chunkPositions[];
};

uniform float time;      //for random seeding
uniform int bounceLimit; //the maximum number of times a light ray can bounce
uniform vec3 sunDir;     //the vector pointing towards the sun, must be normalized

//--------------------------------------------------------------------------------------------------------------------------------//

float rand(float seed) //returns a random float between -1 and 1
{
    return fract(sin(seed) * 43758.5453) * 2.0 - 1.0;
}

vec2 rand2(float seed) //returns a vec2 of random floats between -1 and 1
{
	return vec2(rand(seed), rand(seed * 2.0));
}

vec3 rand3(float seed) //returns a vec3 of random floats between -1 and 1
{
	return vec3(rand(seed), rand(seed * 2.0), rand(seed * 3.0));
}

vec3 rand_unit_sphere(float seed) //returns a vec3 of random floats between -1 and 1 that is inside the unit sphere (mag < 1) 
{
	while(true)
	{
		vec3 point = rand3(seed++);
		if(dot(point, point) >= 1.0)
			continue;

		return point;
	}
}

//--------------------------------------------------------------------------------------------------------------------------------//

void diffuse_ray(ivec3 chunkPos, ivec3 localPos, vec3 normal, vec3 rayPos, Voxel initialVoxel, inout vec3 color) //increments color and numSamples depending on the voxel hit
{
	Voxel hitVoxel = initialVoxel; //stores the voxel that the ray hits
	vec3 hitNormal = normal;       //stores the normal of the hit voxel
	Material hitMaterial;

	vec3 newColor = vec3(1.0);

	vec3 lastPos = rayPos;
	vec3 lastDir;
	for(int i = 0; i < bounceLimit; i++)
	{
		vec3 dir;
		if(i > 0 && (rand(time + bounceLimit + i) + 1) * 0.5 < hitMaterial.specular)
			dir = normalize(reflect(lastDir, hitNormal) * hitMaterial.shininess + rand_unit_sphere(time + i)); //TODO: check if this actually works i cant tell with my current example scene
		else
			dir = normalize(hitNormal + rand_unit_sphere(time + i)); //randomize the direction, spherical sampling
		
		vec3 colorAdd;
		float colorMult;

		bool hit = step_map(dir, 1 / dir, rayPos, true, false, hitVoxel, colorAdd, colorMult);  //step through map
		
		hitNormal = hitVoxel.normal;
		hitMaterial = materials[hitVoxel.material];

		if(hit)
		{
			//return if you hit an adjacent voxel (means that this voxel is occluded):
			vec3 dist = abs(floor(lastPos * CHUNK_SIZE) - floor(rayPos * CHUNK_SIZE));
			if(dot(dist, dist) < 1)
				return;

			//multiply the final color:
			if(hitMaterial.emissive)
			{
				color += newColor * hitVoxel.albedo;
				return;
			}
			else
				newColor *= hitVoxel.albedo;
		}
		else
		{
			color += (newColor * max(dot(dir, sunDir), 0.0) * sunStrength * colorMult + colorAdd) * colorMult; //not sure why i multiply by colorMult twice but it looks better like this
			return;
		}

		lastDir = dir;
	}
}

//--------------------------------------------------------------------------------------------------------------------------------//

void main()
{
	//find positions:
	ivec3 chunkPos = chunkPositions[gl_WorkGroupID.x].xyz;
	ivec3 localPos = ivec3(gl_LocalInvocationID);
	uint chunkIndex = get_map_tile(chunkPos).index;
	Voxel thisVoxel = decompress_voxel(get_voxel(chunkIndex, localPos));

	//return if voxel does not exist lol:
	if(thisVoxel.material == 255)
		return;
	
	//find position of ray (center of the voxel):
	vec3 rayPos = INV_CHUNK_SIZE * localPos + chunkPos + HALF_INV_CHUNK_SIZE;
	rayPos = rayPos + (HALF_INV_CHUNK_SIZE - vec3(EPSILON)) * thisVoxel.normal;

	//send diffuse rays:
	vec3 indirectLight = vec3(0.0);
	diffuse_ray(chunkPos, localPos, thisVoxel.normal, rayPos, thisVoxel, indirectLight);

	//update final lighting and increase number of samples
	vec3 finalColor = (thisVoxel.indirectLight * thisVoxel.indirectSamples + indirectLight) / (thisVoxel.indirectSamples + 1.0);

	chunks[chunkIndex].voxels[localPos.x][localPos.y][localPos.z].indirectLight = finalColor;
	chunks[chunkIndex].voxels[localPos.x][localPos.y][localPos.z].indirectSamples += 1.0;

	return;
}